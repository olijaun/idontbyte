<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A layout example that shows off a blog page with a list of posts.">
    <title>The Problem with Bean Validation</title>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-"
          crossorigin="anonymous">

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css">
    <!--<![endif]-->


    <!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/blog-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/assets/blog.css">
    <!--<![endif]-->


<!--    <link rel="stylesheet"-->
<!--          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css">-->
<!--    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>-->
<!--    <script>hljs.initHighlightingOnLoad();</script>-->

    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-50141806-2', 'auto');
        ga('send', 'pageview');

    </script>

</head>


<body>

<div id="layout" class="pure-g">

    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <h1 class="brand-title">I don't byte</h1>
        <h2 class="brand-tagline">Oliver Jaun's Blog On Software Development</h2>

        <nav class="nav">
            <ul class="nav-list">
                <li class="nav-item">
                    <a class="pure-button" href="/">Home</a>
                </li>
                <li class="nav-item">
                    <a class="pure-button" href="/about.html">About</a>
                </li>
            </ul>
        </nav>
    </div>
</div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <!-- A single blog post -->
        <section class="post">

            <header class="post-header">

                <h2 class="post-title">The Problem with Bean Validation</h2>

                <p class="post-meta">
                    By <a class="post-anchor" href="/about">Oliver Jaun</a>,
                    
                    <time datetime='2019-10-10'>Oct 10, 2019</time>
                    

                    


                    
                    <a class="post-category post-category-java" href="#">java</a>
                    
                    <a class="post-category post-category-design" href="#">design</a>
                    
                </p>
            </header>

            <div class="post-description">
                <p>
                    <p>I’ve never really looked into <a href="https://jcp.org/en/jsr/detail?id=380">Java Bean Validation</a> until some architects at my company suggested it. After going through a tutorial I was not convinced… So I googled for “Bean Validation is bad” in order to see if I’m the only one. And I was not…</p>

<p>One of the first blog posts that appeared was <a href="https://in.relation.to/2014/06/19/blah-vs-bean-validation-you-missed-the-point-like-mars-climate-orbiter/">this one here</a> written by Emmanual Bernard which was the Spec Lead of Bean Validation. In his post he’s is defending Bean Validation which is not surprising of course.</p>

<p>The guy who confirmed my doubts was a guy named Oliver Gierke (who seems to have a nice blog <a href="http://olivergierke.de">here</a>). However this was just a comment in the comment section of the blog and I think this topic deserves a full blog post. I will also show hot to “properly” use Bean Validation. But let’s start in the beginning.</p>

<h1 id="whats-the-problem">What’s the problem?</h1>

<p>I assume that you have some basic knowledge of bean validation (if not then <a href="https://www.baeldung.com/javax-validation">this article here</a> might be a good introduction). Let’s look at the example Oliver is using in his response to Emmanuel’s post:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="nd">@NotNull</span> <span class="nd">@Email</span>
    <span class="nc">String</span> <span class="n">emailAddress</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>This assures that the email address cannot be null and that it is an email address. Note that in order for these rules to be applied you need to trigger somehow a validator that will do the actual validation (a common implementation would be <a href="https://hibernate.org/validator/">hibernate-validator</a>)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">ValidatorFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">Validation</span><span class="o">.</span><span class="na">buildDefaultValidatorFactory</span><span class="o">();</span>
<span class="nc">Validator</span> <span class="n">validator</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getValidator</span><span class="o">();</span></code></pre></figure>

<p>In case you’re using JEE or some Spring extensions the frameworks might take care of the validation. So instead of triggering the validation yourself in an stateless session bean you could just write the following and the framework (e.g. JEE in this example) will take care of <code class="highlighter-rouge">User</code> validation.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Stateless</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyBean</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>The <code class="highlighter-rouge">@Valid</code> annotation makes sure the validation recurses to all fields that are annotated with @Valid. If you forget <code class="highlighter-rouge">@Valid</code> then nothing will be validated.</p>

<p>Let’s look at an alternative approach Oliver Gierke is proposing:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">EmailAddress</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="nf">EmailAddress</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
	  <span class="c1">// explicit null check</span>
	  <span class="c1">// regex validation</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">EmailAddress</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
	  <span class="c1">// reject null email</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>A new class <code class="highlighter-rouge">EmailAddress</code> is introduced. The constructor explicitly validates the value. In other words: the constructor is doing what it was made for:</p>

<blockquote>
  <p>They [constructors] have the task of initializing the object’s data members and of establishing the invariant of the class, failing if the invariant is invalid. <a href="https://en.wikipedia.org/w/index.php?title=Constructor_(object-oriented_programming)&amp;oldid=919933748">Wikipedia</a></p>
</blockquote>

<p>So by using Bean Validation you are basically ignoring essential object oriented principals. Also you’re tying your domain objects to a framework which is not really a good idea according to <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a> the framwork is a “detail”. So why would anyone invent something like Bean Validation? The specification states:</p>

<blockquote>
  <p>To avoid duplication of these validations in each layer, developers often bundle validation logic directly into the domain model, cluttering domain classes with validation code that is, in fact, metadata about the class itself.</p>
</blockquote>

<p>I do not agree with this. Validation logic is essential business logic! It is not meta data. You’re domain logic expects something to be an “email address”, a “contract number” or a “name” etc. also, Emmanual Bernard thinks that developers are lazy:</p>

<blockquote>
  <p>If you do that in your projects kudos. Most developers including me are more lazy :)</p>
</blockquote>

<p>I think it is the opposite: If they were lazy they would probably define an EmailAddress class. It is simpler to just create an <code class="highlighter-rouge">EmailAddress</code> object once and simply pass it around instead of adding validation annotations everywhere.</p>

<p>If you still think that it is a lot of work to create such objects then think about behaviour:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">EmailAddress</span> <span class="n">emailAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EmailAddress</span><span class="o">(</span><span class="s">"james.bond@mi6.co.uk"</span><span class="o">);</span>

<span class="n">emailAddress</span><span class="o">.</span><span class="na">punyEncoded</span><span class="o">();</span> <span class="c1">// returns a punny encoded string</span>
<span class="n">emailAddress</span><span class="o">.</span><span class="na">isGmailAddress</span><span class="o">();</span> <span class="c1">// returns true if email ends with gmail.com or google.com etc.</span>
<span class="n">emailAddress</span><span class="o">.</span><span class="na">getDomainPart</span><span class="o">();</span> <span class="c1">// returns "mi6.co.uk"</span>
<span class="n">emailAddress</span><span class="o">.</span><span class="na">getLocalPart</span><span class="o">();</span> <span class="c1">// returns "james.bond"</span></code></pre></figure>

<p>This is what objects are all about… We want to avoid an anemic domain model:</p>

<blockquote>
  <p>The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters <a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html">Martin Fowler (25 November 2003)</a></p>
</blockquote>

<p>It’s amazing how Java developers try to avoid objects. I think the problem comes from the history of Java and frameworks like JEE and JPA that forced people to implement classes with empty constructors. In JPA you are forced to create DTOs which are not Objects but data structures. The “O” in “ORM” stands for Object but what you are doing is mapping data from the database to a data structure. There is <a href="https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html">very funny blog post from Robert C. Martin (Uncle Bob)</a> where he writes about it. Don’t miss it.</p>

<p>It’s also very simple to test the <code class="highlighter-rouge">User</code> object containing the EmailAddress object.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">invalid</span><span class="o">()</span> <span class="o">{</span>
    
    <span class="nc">Execution</span> <span class="n">e</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="k">new</span> <span class="nc">EMailAddress</span><span class="o">(</span><span class="s">"invalid@@@@@@email.com"</span><span class="o">));</span>
    
    <span class="n">assertThrows</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Pretty simple, right? Now with Bean Validation:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">invalid</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"invalid@@@@@@email.com"</span><span class="o">);</span>
    
    <span class="nc">ValidatorFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">Validation</span><span class="o">.</span><span class="na">buildDefaultValidatorFactory</span><span class="o">();</span>
    <span class="nc">Validator</span> <span class="n">validator</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getValidator</span><span class="o">();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ConstraintViolation</span><span class="o">&lt;</span><span class="nc">AdditionBean</span><span class="o">&gt;&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">validator</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">bean</span><span class="o">);</span>
    <span class="n">assertTrue</span><span class="o">(</span><span class="n">errors</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>So which test would you prefer as a lazy programmer? Of course I’m exaggerating a bit. As you can see Bean Validation seems to offer something called a ConstraintViolation. The EmailAddress doesn’t have this “out-of-the-box” but it could certainly be implemented although I would not do it. I’ll explain later why.</p>

<p>Now, after bad-mouthing bean validation let’s talk about its virtues.</p>

<h1 id="how-to-avoid-the-problems-with-bean-validation">How to avoid the problems with bean validation</h1>

<p>You can find the “final solution” <a href="https://github.com/olijaun/playground/tree/master/beanvalidation-example">in my github repository</a>. Assume the following request to a registration service:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">curl <span class="nt">-X</span> POST http://localhost:8080/registrations <span class="se">\ </span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'
{ 
  "emailAddress": "abc@def.ch", 
  "name": "Oliver Jaun", 
  "password": "secret" 
}'</span></code></pre></figure>

<p>There can be several validation error here. Now let’s look at the webservice implementation (using jax-rs):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Path</span><span class="o">(</span><span class="s">"/registrations"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationResource</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">private</span> <span class="nc">RegistrationService</span> <span class="n">registrationService</span><span class="o">;</span>

    <span class="nd">@POST</span>
    <span class="nd">@Produces</span><span class="o">({</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">TEXT_PLAIN</span><span class="o">})</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Response</span> <span class="nf">register</span><span class="o">(</span><span class="nc">RegistrationDto</span> <span class="n">registrationDto</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">EmailAddress</span> <span class="n">emailAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EmailAddress</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getEmailAddress</span><span class="o">());</span>

        <span class="nc">RegistrationCommand</span> <span class="n">registrationCommand</span>
                <span class="o">=</span> <span class="k">new</span> <span class="nc">RegistrationCommand</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">emailAddress</span><span class="o">,</span> <span class="n">registrationDto</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span>

        <span class="nc">RegistrationId</span> <span class="n">registrationId</span> <span class="o">=</span> <span class="n">registrationService</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">registrationCommand</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">registrationId</span><span class="o">.</span><span class="na">asString</span><span class="o">()).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>The <code class="highlighter-rouge">register</code> method receives a RegistrationDto. A Dto is not really an object it is a data structure. It is mutable and has getter and setter methods for modification. First the email address from the registrationDto is converted into an <code class="highlighter-rouge">EmailAddress</code> object. After this a <code class="highlighter-rouge">RegistrationCommand</code> is created that is passed to the <code class="highlighter-rouge">RegistrationService</code> which belongs to our domain model. The <code class="highlighter-rouge">RegistrationCommand</code> verifies that name, email address and password are not null. Note that the <code class="highlighter-rouge">RegistrationCommand</code> is created in the REST service implementation but it belongs and is defined in the domain model.</p>

<p>In the domain model we then have a RegistrationCommand that is valid and we can work with, without ever having to validate again. Note that the <code class="highlighter-rouge">RegistrationCommand</code> and the <code class="highlighter-rouge">EmailAddress</code> are immutable. So it is not possible that they suddenly are not valid anymore.</p>

<p>The problem with this is, that if the user passes an invalid email address then the <code class="highlighter-rouge">EmailAddress</code> will throw an <code class="highlighter-rouge">IllegalArgumentException</code> or a <code class="highlighter-rouge">NullPointerException</code>. Those are unchecked exceptions and jax-rs will create a HTTP response with the status code 500. However a RESTful service should respond with a 4xx status in such cases. So you could catch these errors and return the correct status code:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="nd">@Path</span><span class="o">(</span><span class="s">"/registrations"</span><span class="o">)</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationResource</span> <span class="o">{</span>
 
     <span class="nd">@Inject</span>
     <span class="kd">private</span> <span class="nc">RegistrationService</span> <span class="n">registrationService</span><span class="o">;</span>
 
     <span class="nd">@POST</span>
     <span class="nd">@Produces</span><span class="o">({</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">TEXT_PLAIN</span><span class="o">})</span>
     <span class="nd">@Path</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
     <span class="kd">public</span> <span class="nc">Response</span> <span class="nf">register</span><span class="o">(</span><span class="nc">RegistrationDto</span> <span class="n">registrationDto</span><span class="o">)</span> <span class="o">{</span>
 
         <span class="nc">EmailAddress</span> <span class="n">emailAddress</span><span class="o">;</span>
         <span class="k">try</span> <span class="o">{</span>
             <span class="n">emailAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EmailAddress</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getEmailAddress</span><span class="o">());</span>
         <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">Response</span><span class="o">.</span><span class="na">Status</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">).</span><span class="na">entity</span><span class="o">(</span><span class="s">"invalid email address format"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
         <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NullPointerException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">Response</span><span class="o">.</span><span class="na">Status</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">).</span><span class="na">entity</span><span class="o">(</span><span class="s">"email address is mandatory"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
         <span class="o">}</span>
 
         <span class="nc">RegistrationCommand</span> <span class="n">registrationCommand</span>
                 <span class="o">=</span> <span class="k">new</span> <span class="nc">RegistrationCommand</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">emailAddress</span><span class="o">,</span> <span class="n">registrationDto</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span>
 
         <span class="nc">RegistrationId</span> <span class="n">registrationId</span> <span class="o">=</span> <span class="n">registrationService</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">registrationCommand</span><span class="o">);</span>
 
         <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">registrationId</span><span class="o">.</span><span class="na">asString</span><span class="o">()).</span><span class="na">build</span><span class="o">();</span>
     <span class="o">}</span>
 <span class="o">}</span>
 </code></pre></figure>

<p>Quite a lot of code just for an email address. Apart form that it would also be necessary to do something similar with the <code class="highlighter-rouge">RegistrationCommand</code>. This would be even more difficult because the <code class="highlighter-rouge">RegistrationCommand</code> contains three attributes. The name, the email address or the password… any of these could be wrong. How do we handle this properly?</p>

<p>Assuming multiple things are wrong a UI would probably want to display all things at once. This code would get event more complicated because it would be necessary to collect multiple validation errors and return them summarized. That’s where bean validation comes into play. First we add some annotations to the <code class="highlighter-rouge">RegistrationDto</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationDto</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="nd">@Email</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">emailAddress</span><span class="o">;</span>
    <span class="nd">@NotNull</span> <span class="nd">@NotBlank</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nd">@NotNull</span> <span class="nd">@NotBlank</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

    <span class="c1">// setters and getters</span>
<span class="o">}</span></code></pre></figure>

<p>It is fine to have Bean Validation annotations on DTOs because - as I said before - they are data structures not objects. Also because the DTOs do not live in the domain model so it is OK to tie them to a framework. In the jax-rs service implementation we just add <code class="highlighter-rouge">@NotNull</code> and <code class="highlighter-rouge">@Valid</code> annotation to the <code class="highlighter-rouge">register</code> method which is fine as well because you are using the jax-rs framework anyway.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Path</span><span class="o">(</span><span class="s">"/registrations"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationResource</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">private</span> <span class="nc">RegistrationService</span> <span class="n">registrationService</span><span class="o">;</span>

    <span class="nd">@POST</span>
    <span class="nd">@Produces</span><span class="o">({</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">TEXT_PLAIN</span><span class="o">})</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Response</span> <span class="nf">register</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nd">@Valid</span> <span class="nc">RegistrationDto</span> <span class="n">registrationDto</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">EmailAddress</span> <span class="n">emailAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EmailAddress</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getEmailAddress</span><span class="o">());</span>

        <span class="nc">RegistrationCommand</span> <span class="n">registrationCommand</span>
                <span class="o">=</span> <span class="k">new</span> <span class="nc">RegistrationCommand</span><span class="o">(</span><span class="n">registrationDto</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">emailAddress</span><span class="o">,</span> <span class="n">registrationDto</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span>

        <span class="nc">RegistrationId</span> <span class="n">registrationId</span> <span class="o">=</span> <span class="n">registrationService</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">registrationCommand</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">registrationId</span><span class="o">.</span><span class="na">asString</span><span class="o">()).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Actually the bean validation will also throw unchecked exceptions. In order to not produce a status code 500 a ExceptionMapper is needed. An ExceptionMapper in jax-rs allows to map Exceptions to return codes. So here is a custom mapper that maps <code class="highlighter-rouge">ConstraintViolationException</code>s to an <code class="highlighter-rouge">ErrorDto</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Provider</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstraintViolationExceptionMapper</span> <span class="kd">implements</span> <span class="nc">ExceptionMapper</span><span class="o">&lt;</span><span class="nc">ConstraintViolationException</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Response</span> <span class="nf">toResponse</span><span class="o">(</span><span class="nc">ConstraintViolationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ValidationErrorDto</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getConstraintViolations</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ValidationErrorDto</span><span class="o">(</span><span class="n">toLocation</span><span class="o">(</span><span class="n">v</span><span class="o">),</span> <span class="n">v</span><span class="o">.</span><span class="na">getMessage</span><span class="o">())).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
        <span class="nc">ErrorDto</span> <span class="n">errorDto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ErrorDto</span><span class="o">();</span>
        <span class="n">errorDto</span><span class="o">.</span><span class="na">getErrors</span><span class="o">().</span><span class="na">addAll</span><span class="o">(</span><span class="n">collect</span><span class="o">);</span>


        <span class="k">return</span> <span class="nc">Response</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">Response</span><span class="o">.</span><span class="na">Status</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">).</span><span class="na">entity</span><span class="o">(</span><span class="n">errorDto</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">toLocation</span><span class="o">(</span><span class="nc">ConstraintViolation</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">pathElements</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">getPropertyPath</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">pathElements</span><span class="o">).</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">"."</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Note that I’m doing some fancy stuff with the path because the path contains the name of the java method. I think this name should not end up in an error message because it is implementation specific. Now let’s see how this looks like when the service is invoked with invalid data:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">curl <span class="nt">-X</span> POST http://localhost:8080/registrations <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'
  {
    "name":"", 
    "emailAddress": "oliver@@jaun.org", 
    "password": "password123" 
  }'</span>
  
<span class="o">{</span>
  <span class="s2">"errors"</span> : <span class="o">[</span> <span class="o">{</span>
    <span class="s2">"location"</span> : <span class="s2">"name"</span>,
    <span class="s2">"message"</span> : <span class="s2">"must not be blank"</span>
  <span class="o">}</span>, <span class="o">{</span>
    <span class="s2">"location"</span> : <span class="s2">"emailAddress"</span>,
    <span class="s2">"message"</span> : <span class="s2">"must be a well-formed email address"</span>
  <span class="o">}</span> <span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>This is nice: you can use the advantages of the Bean Validation framework but your domain model (EmailAddress etc.) stays clean. In your domain model you can rely on the objects to be properly validated. Look at the RegistrationService in the domain model:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">RegistrationId</span> <span class="nf">register</span><span class="o">(</span><span class="nc">RegistrationCommand</span> <span class="n">registrationCommand</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// perform registration</span>

        <span class="k">return</span> <span class="n">registrationId</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>There is no bean validation at all and we can implement our domain logic without having to worry about anything. The RegistrationCommand will be valid because the constructor of the RegistrationCommand will make sure it is. Bean Validation is just a detail that is used outside of the domain logic in order to provide nice user error message to the user.</p>

<p>But what happens if we forget to add the <code class="highlighter-rouge">@Valid</code> annotation? In this case the RESTful service still returns status code 500 because the instantiation of the domain object will throw an unchecked exception (e.g. <code class="highlighter-rouge">IllegalArgumentException</code>). This is fine. Firstly: it should not happen if you write tests. Secondly if it happens then it’s a bug. Whenever the service returns status code 500 this should be logged. The error must be analyzed and then fixed as you do with any other bug.</p>

<p>Note that the example could still be improved. IMHO there should be no plain error messages be returned by a REST service. I’m working for a swiss company and we have to support german, french and italian. What does the service return? German? French? English? All of them? Also an application calling this service might not just display a message but react to accordingly in case of an error. So I think it would be better to return some kind of error code instead of a plain error message.</p>

<h1 id="some-more-thoughts">Some more thoughts</h1>

<p>It could be argued that validation logic is now implemented twice. Once in the implementation for the <code class="highlighter-rouge">@Email</code> annotation and once in the domain model by the <code class="highlighter-rouge">EmailAddress</code> class. Yes this is true but often the validation logic can be shared. Let’s look at an extended version of the <code class="highlighter-rouge">EmailAddress</code> class:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailAddress</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">EMAIL_ADDRESS_PATTERN</span> <span class="o">=</span> <span class="s">"[^@]+@[^@]+"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">emailAddress</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">EmailAddress</span><span class="o">(</span><span class="nc">String</span> <span class="n">emailAddress</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">emailAddress</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">emailAddress</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(!</span><span class="n">emailAddress</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="no">EMAIL_ADDRESS_PATTERN</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid email address: "</span> <span class="o">+</span> <span class="n">emailAddress</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">asString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">emailAddress</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is not a proper email address pattern, I agree. Email address validation is quite difficult. For the sake of demonstration I still use this simplified pattern.</p>

<p>As stated above one of my objections with bean validation is that your domain model should not depend on it. However it is fine if your application- or infrastructure layer depends on the domain logic. In order to not duplicate the validation we can reuse the EmailAddress validation in the RESTful service implementation. One possibility is to just use the <code class="highlighter-rouge">EMAIL_ADDRESS_PATTERN</code> defined by the <code class="highlighter-rouge">EmailAddress</code> class in the <code class="highlighter-rouge">RegistrationDto</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationDto</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="nd">@NotNull</span>
    <span class="nd">@Pattern</span><span class="o">(</span><span class="n">regexp</span> <span class="o">=</span> <span class="nc">EmailAddress</span><span class="o">.</span><span class="na">EMAIL_ADDRESS_PATTERN</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">emailAddress</span><span class="o">;</span>
    <span class="nd">@NotNull</span>
    <span class="nd">@NotBlank</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nd">@NotNull</span>
    <span class="nd">@NotBlank</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>So instead of the <code class="highlighter-rouge">@Email</code> annotation the <code class="highlighter-rouge">@Pattern</code> annotation is used which accepts a regular expression. This is a pragmatic approach in many situations. If the validation cannot be expressed by a regular expression, then another solution would be to create a new bean bean validation annotation:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">({</span><span class="no">METHOD</span><span class="o">,</span> <span class="no">FIELD</span><span class="o">,</span> <span class="no">ANNOTATION_TYPE</span><span class="o">,</span> <span class="no">CONSTRUCTOR</span><span class="o">,</span> <span class="no">PARAMETER</span><span class="o">,</span> <span class="no">TYPE_USE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Constraint</span><span class="o">(</span><span class="n">validatedBy</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">EmailAddressValidator</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">ValidEmailAddress</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">message</span><span class="o">()</span> <span class="k">default</span> <span class="s">"invalid email address {value}"</span><span class="o">;</span>

    <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">groups</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Payload</span><span class="o">&gt;[]</span> <span class="nf">payload</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>
<span class="o">}</span></code></pre></figure>

<p>Then the <code class="highlighter-rouge">EmailAddressValidator</code> has to be created, which basically delegates the validation to our <code class="highlighter-rouge">EmailAddress</code> class.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailAddressValidator</span> <span class="kd">implements</span> <span class="nc">ConstraintValidator</span><span class="o">&lt;</span><span class="nc">ValidEmailAddress</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="nc">ValidEmailAddress</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="nc">String</span> <span class="n">emailAddressAsString</span><span class="o">,</span> <span class="nc">ConstraintValidatorContext</span> <span class="n">constraintValidatorContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// null values are valid</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">emailAddressAsString</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">EmailAddress</span><span class="o">(</span><span class="n">emailAddressAsString</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h1 id="summary">Summary</h1>

<p>Bean Validation is not as bad as long as it is NOT used in the domain model of an application.</p>

<p>The proposed approach of combining bean validation with proper domain objects that validate themselves has several advantages:</p>

<p>Domain Objects remain “clean” (they do not depend on a framework) and can simply throw <code class="highlighter-rouge">NullPointerException</code>s or <code class="highlighter-rouge">IllegalArgumentException</code>s in case that validations fails in the constructor.</p>

<p>Bean Validation is used where it “shines”. It is applied only on the outer layer of an application and allows for validation with detailed messages. It also allows for multiple validation errors to be returned at once.</p>

<p>The disadvantage of the approach is that there is a certain redundancy in validation which can however be minimized by sharing validation code.</p>

                </p>
            </div>
        </section>

        


<div id="disqus_thread"></div>
<script>

    var disqus_config = function () {
        this.page.url = "http://idontbyte.jaun.org/blog/2019/10/banvalidation";  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = "/blog/2019/10/banvalidation"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//idontbyte-jaun-org.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



        

<div class="footer">
    <div class="pure-menu pure-menu-horizontal">
        &copy; 2019 - Oliver Jaun
        <ul>
            <li class="pure-menu-item"><a href="/privacy_policy.html" class="pure-menu-link">Privacy Policy</a></li>
            <li class="pure-menu-item"><a href="/disclosure_statement.html" class="pure-menu-link">Disclosure Statement</a></li>
        </ul>
    </div>
</div>
    </div>



</div>


</body>

</html>